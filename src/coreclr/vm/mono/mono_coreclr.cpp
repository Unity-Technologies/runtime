#include "common.h"

#include "MonoCoreClr.h"
#include <coreclrhost.h>

#include "../../gc/gcscan.h"
#include "../../gc/objecthandle.h"
#include "assembly.hpp"
#include "assemblynative.hpp"
#include "caparser.h"
#include "ecall.h"
#include "mscoree.h"
#include "stringliteralmap.h"
#include "threadlocalpoolallocator.h"
#include "threads.h"
#include "threadsuspend.h"
#include "typeparse.h"
#include "typestring.h"
#include "profilepriv.h"

#ifdef FEATURE_PAL
#include "pal.h"
#endif // FEATURE_PAL

// we only need domain reload for Editor
// #define UNITY_SUPPORT_DOMAIN_UNLOAD 1

// Match the behavior of Unity.  We need to flush immediately because this is used to log stack traces
// on the managed side of the embedding api before we call Environment.Exit.  If we were to let the msg be buffered we may not
// always see the stack trace before the application exits.
#ifdef WIN32
int __cdecl print_and_flush(const char* msg, va_list args)
#else
int print_and_flush(const char* msg, va_list args)
#endif
{
    auto result = vprintf(msg, args);
    printf("\n");
    fflush(stdout);
    return result;
}

static vprintf_func our_vprintf = print_and_flush;

void unity_log(const char *format, ...)
{
    va_list args;
    va_start (args, format);
    our_vprintf (format, args);
    va_end (args);
    our_vprintf ("\n", nullptr);
}

static gboolean s_ReturnHandlesFromAPI;

static gboolean return_handles_from_api()
{
    return s_ReturnHandlesFromAPI;
}

#ifdef WIN32
#define EXPORT_API __declspec(dllexport)
#define EXPORT_CC __cdecl
#define PATH_SEPARATOR ';'
#else
#define EXPORT_API __attribute__((visibility("default")))
#define EXPORT_CC
#define PATH_SEPARATOR ':'
#endif

//#define TRACE_API(format,...) { printf("%s (" format ")\n", __func__, __VA_ARGS__); fflush(stdout); }
#define TRACE_API(format,...)

void* g_CLRRuntimeHost;
unsigned int g_RootDomainId;

typedef intptr_t ManagedStringPtr_t;

// Generated by UnityEmbedHost.Generator - Commit these changes
struct HostStruct
{
    MonoClass* (*array_class_get)(MonoClass* klass, guint32 rank);
    int (*array_length)(MonoArray* array);
    MonoArray* (*array_new)(MonoDomain* domain, MonoClass* klass, guint32 n);
    MonoObject* (*assembly_get_object)(MonoDomain* domain, MonoAssembly* assembly);
    MonoAssembly* (*assembly_loaded)(MonoAssemblyName* aname);
    MonoClass* (*class_from_name)(MonoImage* image, const char* name_space, const char* name, gboolean ignoreCase);
    MonoClass* (*class_from_systemtypeinstance)(MonoObject* systemTypeInstance);
    MonoImage* (*class_get_image)(MonoClass* klass);
    int (*class_get_rank)(MonoClass* klass);
    gboolean (*class_is_blittable)(MonoClass* klass);
    gboolean (*class_is_enum)(MonoClass* klass);
    gboolean (*class_is_generic)(MonoClass* klass);
    gboolean (*class_is_inflated)(MonoClass* klass);
    gboolean (*class_is_subclass_of)(MonoClass* klass, MonoClass* parent_class, gboolean check_interfaces);
    gboolean (*class_is_valuetype)(MonoClass* klass);
    MonoException* (*exception_from_name_msg)(MonoImage* image, const char* name_space, const char* name, const char* msg);
    MonoReflectionField* (*field_get_object)(MonoDomain* domain, MonoClass* klass, MonoClassField* field);
    gint64 (*gc_get_used_size)();
    MonoImage* (*get_corlib)();
    MonoException* (*get_exception_argument_null)(const char* arg);
    MonoMethod* (*get_method)(MonoImage* image, guint32 token, MonoClass* klass);
    const char* (*image_get_filename)(MonoImage* image);
    const char* (*image_get_name)(MonoImage* image);
    MonoImage* (*image_loaded)(const char* name);
    MonoReflectionMethod* (*method_get_object)(MonoDomain* domain, MonoMethod* method, MonoClass* refclass);
    MonoClass* (*object_get_class)(MonoObject* obj);
    MonoMethod* (*object_get_virtual_method)(MonoObject* obj, MonoMethod* method);
    MonoObject* (*object_isinst)(MonoObject* obj, MonoClass* klass);
    MonoObject* (*object_new)(MonoDomain* domain, MonoClass* klass);
    ManagedStringPtr_t (*string_from_utf16)(const gunichar2* text);
    ManagedStringPtr_t (*string_new_len)(MonoDomain* domain, const char* text, guint32 length);
    ManagedStringPtr_t (*string_new_utf16)(MonoDomain* domain, const guint16* text, gint32 length);
    MonoObject* (*type_get_object)(MonoDomain* domain, MonoType* type);
    MonoArray* (*unity_array_new_2d)(MonoDomain* domain, MonoClass* klass, size_t size0, size_t size1);
    MonoArray* (*unity_array_new_3d)(MonoDomain* domain, MonoClass* klass, size_t size0, size_t size1, size_t size2);
    MonoObject* (*unity_assembly_get_attribute)(MonoAssembly* assembly, MonoClass* attr_klass);
    MonoClass* (*unity_class_get)(MonoImage* image, guint32 token);
    MonoObject* (*unity_class_get_attribute)(MonoClass* klass, MonoClass* attr_klass);
    gboolean (*unity_class_is_abstract)(MonoClass* klass);
    gboolean (*unity_class_is_interface)(MonoClass* klass);
    MonoClassField* (*unity_field_from_token_checked)(MonoImage* image, guint32 token, MonoClass** retklass);
    MonoObject* (*unity_field_get_attribute)(MonoClass* klass, MonoClassField* field, MonoClass* attr_class);
    MonoObject* (*unity_method_get_attribute)(MonoMethod* method, MonoClass* attr_class);
    void* (*unity_method_get_function_pointer)(MonoMethod* method);
    gboolean (*unity_mono_method_is_generic_specific)(MonoMethod* method, MonoClass* klass);
    gboolean (*unity_mono_method_is_inflated_specific)(MonoMethod* method, MonoClass* klass);
    MonoObject* (*value_box)(MonoDomain* domain, MonoClass* klass, gpointer val);
};
HostStruct* g_HostStruct;

struct HostStructNative
{
    void (*unity_log)(const char *format);
    gboolean (*return_handles_from_api)();
};
HostStructNative* g_HostStructNative;

thread_local MonoDomain *gCurrentDomain = NULL;
MonoDomain *gRootDomain = NULL;
EXTERN_C IMAGE_DOS_HEADER __ImageBase;

CrstStatic g_add_internal_lock;

static SString* s_AssemblyDir;
static SString* s_EtcDir;
static SString* s_AssemblyPaths;

// Import this function manually as it is not defined in a header
extern "C" HRESULT  GetCLRRuntimeHost(REFIID riid, IUnknown **ppUnk);

#define ASSERT_NOT_IMPLEMENTED printf("Function not implemented: %s\n", __func__);

#define kCoreCLRHelpersDll "unity-embed-host.dll"
#define FIELD_ATTRIBUTE_PRIVATE               0x0001
#define FIELD_ATTRIBUTE_FAMILY                0x0004
#define FIELD_ATTRIBUTE_PUBLIC                0x0006

template <COUNT_T MEMSIZE>
static STRINGREF AllocateString(const InlineSString<MEMSIZE>& sstr)
{
    STRINGREF strObj = AllocateString(sstr.GetCount());
    memcpyNoGCRefs(strObj->GetBuffer(), sstr.GetUnicode(), sstr.GetCount() * sizeof(WCHAR));
    return strObj;
}

class GCNativeFrame : public Frame
{
    VPTR_VTABLE_CLASS(GCNativeFrame, Frame)

public:

    GCNativeFrame() {
        stackBase = NULL;
    };

    VOID Pop();

    virtual void GcScanRoots(promote_func *fn, ScanContext* sc)
    {
        for (UINT32 i=0; i<bits.GetCount(); i++)
        {
            UInt64 mask = bits[i];
            for (int j=0; mask != 0; j++, mask >>= 1)
            {
                if (mask & 1)
                {
                    void *ptr = stackBase - (i * sizeof(UInt64) * 8) - j;
                    fn ((PTR_PTR_Object)ptr, sc, 0);
                }
            }
        }
    }

    void PushStackPtr(void **addr)
    {
        if (stackBase < addr)
            stackBase = addr + 1024;
        ptrdiff_t bitOffs = stackBase - addr;
        size_t arrayIndex = bitOffs / (sizeof(UInt64) * 8);
        UInt64 bitIndex = bitOffs % (sizeof(UInt64) * 8);
        size_t count = bits.GetCount();
        if (count < arrayIndex + 1)
        {
            bits.SetCount((COUNT_T)arrayIndex + 1);
            for (size_t i=count;i<=arrayIndex;i++)
                bits[(COUNT_T)i] = 0;
        }
        bits[(COUNT_T)arrayIndex] |= 1LL << bitIndex;
    }

    void PopStackPtr(void **addr)
    {
        ptrdiff_t bitOffs = stackBase - addr;
        size_t arrayIndex = bitOffs / (sizeof(UInt64) * 8);
        UInt64 bitIndex = bitOffs % (sizeof(UInt64) * 8);
        if (bits.GetCount() > arrayIndex)
            bits[(COUNT_T)arrayIndex] &= ~(1LL << bitIndex);
    }

private:
    void **stackBase;
    SArray<UInt64> bits;

    // Keep as last entry in class
    DEFINE_VTABLE_GETTER_AND_DTOR(GCNativeFrame)
};

#ifndef __GNUC__
__declspec(thread) GCNativeFrame * pCurrentThreadNativeFrame;
#else // !__GNUC__
thread_local GCNativeFrame * pCurrentThreadNativeFrame;
#endif // !__GNUC__

thread_local int g_isManaged = 0;

typedef Assembly MonoAssembly_clr;
typedef Assembly MonoImage_clr;
typedef Object MonoObject_clr;
typedef FieldDesc MonoClassField_clr; // struct MonoClassField;
typedef MethodTable MonoClass_clr; //struct MonoClass;
typedef AppDomain MonoDomain_clr; //struct MonoDomain;
typedef MethodDesc MonoMethod_clr;
typedef OBJECTREF MonoObjectRef_clr;
typedef TypeHandle MonoType_clr;
typedef ArrayBase MonoArray_clr;
typedef Thread MonoThread_clr;
typedef MethodDesc MonoMethodSignature_clr;

static inline MonoType_clr MonoType_clr_from_MonoType(MonoType* type)
{
    return MonoType_clr::FromPtr(type);
}

static inline MonoType* MonoType_clr_to_MonoType(MonoType_clr type)
{
    return (MonoType*)type.AsPtr();
}

static void get_dirname(char* source)
{
    for (size_t i = strlen(source) - 1; i >= 0; i--)
    {
        if (source[i] == '/' || source[i] == '\\')
        {
            source[i + 1] = '\0';
            return;
        }
    }
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API int EXPORT_CC coreclr_array_length(MonoArray* array)
{
    return g_HostStruct->array_length(array);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoClass* EXPORT_CC coreclr_class_from_systemtypeinstance(MonoObject* systemTypeInstance)
{
    return g_HostStruct->class_from_systemtypeinstance(systemTypeInstance);
}

extern "C" EXPORT_API void EXPORT_CC mono_add_internal_call(const char *name, gconstpointer method)
{
    TRACE_API("%s, %p", name, method);

    assert(name != nullptr);
    assert(method != nullptr);
    CrstHolder lock(&g_add_internal_lock);
    ECall::RegisterICall(name, (PCODE)method);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoClass* EXPORT_CC mono_array_class_get(MonoClass* klass, guint32 rank)
{
    return g_HostStruct->array_class_get(klass, rank);
}

extern "C" EXPORT_API int EXPORT_CC mono_array_element_size(MonoClass* classOfArray)
{
    CONTRACTL
    {
        NOTHROW;
        GC_NOTRIGGER;
        PRECONDITION(classOfArray != NULL);
    }
    CONTRACTL_END;

    return reinterpret_cast<MonoClass_clr*>(classOfArray)->GetArrayElementTypeHandle().GetSize();
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoArray* EXPORT_CC mono_array_new(MonoDomain* domain, MonoClass* klass, guint32 n)
{
    return g_HostStruct->array_new(domain, klass, n);
}

extern "C" EXPORT_API void EXPORT_CC mono_assembly_foreach (GFunc func, gpointer user_data)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API MonoImage* EXPORT_CC mono_assembly_get_image(MonoAssembly *assembly)
{
    TRACE_API("%p", assembly);
    CONTRACTL
    {
        NOTHROW;
        GC_NOTRIGGER;
        PRECONDITION(assembly != NULL);
    }
    CONTRACTL_END;

    // Assume for now that Assembly == Image
    return (MonoImage*)assembly;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_assembly_get_object(MonoDomain* domain, MonoAssembly* assembly)
{
    return g_HostStruct->assembly_get_object(domain, assembly);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoAssembly* EXPORT_CC mono_assembly_loaded(MonoAssemblyName* aname)
{
    return g_HostStruct->assembly_loaded(aname);
}

extern "C" EXPORT_API gint32 EXPORT_CC mono_class_array_element_size(MonoClass *ac)
{
    CONTRACTL{
        STANDARD_VM_CHECK;
        PRECONDITION(ac != nullptr);
    } CONTRACTL_END;
    auto ac_clr = (MonoClass_clr*)ac;

    // TODO: Is it really the method to use?
    DWORD s = ac_clr->IsValueType() ? ac_clr->GetNumInstanceFieldBytes() : sizeof(void*);// ac_clr->GetBaseSize();
    return s;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_from_mono_type(MonoType *image)
{
    MonoClass_clr* klass = MonoType_clr_from_MonoType(image).GetMethodTable();
    return (MonoClass*)klass;
}

// Note: This function has NOT been generated by the source generator
MonoClass * mono_class_from_name(MonoImage *image, const char* name_space, const char *name, bool ignoreCase)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model

    return g_HostStruct->class_from_name(image, name_space, name, ignoreCase);
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_from_name(MonoImage *image, const char* name_space, const char *name)
{
    TRACE_API("%x, %s, %s", image, name_space, name);

    return mono_class_from_name(image, name_space, name, false);
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_from_name_case(MonoImage *image, const char* name_space, const char *name)
{
    TRACE_API("%x, %s, %s", image, name_space, name);

    return mono_class_from_name(image, name_space, name, true);
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_get_element_class(MonoClass *klass)
{
    CONTRACTL
    {
        NOTHROW;
    GC_NOTRIGGER;
    PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    return (MonoClass*)reinterpret_cast<MonoClass_clr*>(klass)->GetArrayElementTypeHandle().GetMethodTable();
}

extern "C" EXPORT_API MonoClassField* EXPORT_CC mono_class_get_field_from_name(MonoClass *klass, const char *name)
{
    CONTRACTL
    {
    GC_TRIGGERS;
    PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    MonoClass_clr* mt = reinterpret_cast<MonoClass_clr*>(klass);
    FieldDesc* retVal = NULL;
    // FindField only checks the fields of the current class and not inherited ones.
    while (retVal == NULL && mt != NULL)
    {
        retVal = MemberLoader::FindField(mt, name, NULL, NULL, NULL);
        mt = mt->GetParentMethodTable();
    }

    return (MonoClassField*)retVal;
}

thread_local ThreadLocalPoolAllocator<ApproxFieldDescIterator,5> g_ApproxFieldDescIteratorAlloc;

extern "C" EXPORT_API MonoClassField* EXPORT_CC mono_class_get_fields(MonoClass* klass, gpointer *iter)
{
    TRACE_API("%p, %p", klass, iter);

    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    if (!iter)
    {
        return NULL;
    }
    MonoClass_clr* klass_clr = (MonoClass_clr*)klass;

    ApproxFieldDescIterator* iterator = (ApproxFieldDescIterator*)*iter;
    if (iterator == nullptr)
    {
        iterator = g_ApproxFieldDescIteratorAlloc.Alloc();
        iterator->Init(klass_clr, ApproxFieldDescIterator::INSTANCE_FIELDS | ApproxFieldDescIterator::STATIC_FIELDS);
        *iter = iterator;
    }

    auto nextField = iterator->Next();
    if (nextField == nullptr)
    {
        *iter = nullptr;
        g_ApproxFieldDescIteratorAlloc.Free(iterator);
        return nullptr;
    }

    return (MonoClassField*)nextField;
}

extern "C" EXPORT_API guint32 EXPORT_CC mono_class_get_flags(MonoClass *klass)
{
    MonoClass_clr* clrClass = reinterpret_cast<MonoClass_clr*>(klass);
    mdTypeDef token = clrClass->GetCl();
    IMDInternalImport *pImport = clrClass->GetMDImport();
    DWORD           dwClassAttrs;
    pImport->GetTypeDefProps(token, &dwClassAttrs, NULL);
    return dwClassAttrs;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoImage* EXPORT_CC mono_class_get_image(MonoClass* klass)
{
    return g_HostStruct->class_get_image(klass);
}

// Wrap iterator value in heap allocated value we can return from embedding API
struct MethodTable_InterfaceMapIteratorWrapper
{
    MethodTable::InterfaceMapIterator iter;

    MethodTable_InterfaceMapIteratorWrapper(MonoClass_clr* klass_clr) :
        iter(klass_clr->IterateInterfaceMap())
    {
    }
};

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_get_interfaces(MonoClass* klass, gpointer *iter)
{
    TRACE_API("%p, %p", klass, iter);

    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    if (!iter)
    {
        return NULL;
    }
    MonoClass_clr* klass_clr = (MonoClass_clr*)klass;

    MethodTable_InterfaceMapIteratorWrapper* iterator = (MethodTable_InterfaceMapIteratorWrapper*)*iter;
    if (iterator == nullptr)
    {
        iterator = new MethodTable_InterfaceMapIteratorWrapper(klass_clr);
        *iter = iterator;
    }

    if (!iterator->iter.Next())
    {
        *iter = nullptr;
        delete iterator;
        return nullptr;
    }

    // TODO: this used to be a call to GetInterface, not sure of the difference
    return (MonoClass*)iterator->iter.GetInterfaceApprox();
}

extern "C" EXPORT_API MonoMethod* EXPORT_CC mono_class_get_methods(MonoClass* klass, gpointer *iter)
{
    TRACE_API("%p, %p", klass, iter);

    CONTRACTL
    {
        THROWS;
        GC_TRIGGERS;
        PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    if (!iter)
    {
        return NULL;
    }

    MonoClass_clr* klass_clr = (MonoClass_clr*)klass;

    MethodTable::IntroducedMethodIterator* iterator = (MethodTable::IntroducedMethodIterator*)*iter;
    if (iterator == NULL)
    {
        // TODO: Using the option FALSE to iterate methods through a non-canonical type.
        // Not sure exactly what does this mean
        iterator = new MethodTable::IntroducedMethodIterator(klass_clr, 0);
        *iter = iterator;
    }

    if (!iterator->IsValid())
    {
        *iter = NULL;
        delete iterator;
        return NULL;
    }

    auto method = iterator->GetMethodDesc();
    method->EnsureActive();
    iterator->Next();
    return (MonoMethod*)method;
}

extern "C" EXPORT_API const char* EXPORT_CC mono_class_get_name(MonoClass *klass)
{
	MonoClass_clr* clazz = (MonoClass_clr*)klass;
    if (clazz->IsArray())
    {
        const char *elementName = mono_class_get_name(mono_class_get_element_class(klass));
        int rank = clazz->GetRank();
        SString arrayName(SString::Utf8, elementName);
        arrayName += '[';
        for (int i=0; i<rank-1; i++)
            arrayName += ',';
        arrayName += ']';
        static char buf[512] = {0};
        strcpy(buf, arrayName.GetUTF8());
        return buf;
    }

	LPCUTF8 name, namespaze;
	clazz->GetMDImport()->GetNameOfTypeDef(clazz->GetCl(), &name, &namespaze);

    if (name)
        return name;

    DefineFullyQualifiedNameForClass();
    name = GetFullyQualifiedNameForClass(clazz);
    return name;
}

extern "C" EXPORT_API const char* EXPORT_CC mono_class_get_namespace(MonoClass *klass)
{
	MonoClass_clr* clazz = (MonoClass_clr*)klass;
	LPCUTF8 name, namespaze;
	clazz->GetMDImport()->GetNameOfTypeDef(clazz->GetCl(), &name, &namespaze);
    return namespaze;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_get_nested_types(MonoClass* klass, gpointer *iter)
{
    TRACE_API("%p, %p", klass, iter);

    CONTRACTL
    {
        THROWS; // new BYTE
        GC_TRIGGERS; // ClassLoader::LoadTypeDefThrowing
    PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    if (!iter)
    {
        return NULL;
    }

    struct NestedTypesIterator
    {
        ULONG index;
        ULONG count;
        mdTypeDef tokens[];
    };

    MonoClass_clr* klass_clr = (MonoClass_clr*)klass;

    NestedTypesIterator* nestedIterator = (NestedTypesIterator*)*iter;
    if (nestedIterator == NULL)
    {
        mdTypeDef token = klass_clr->GetCl();
        IMDInternalImport *pImport = klass_clr->GetMDImport();
        ULONG nestedCount;
        pImport->GetCountNestedClasses(token, &nestedCount);
        // Early exit if there is no nested classes
        if (nestedCount == 0)
        {
            return NULL;
        }
        SIZE_T sizeOfIterator = sizeof(NestedTypesIterator) + sizeof(mdTypeDef) * nestedCount;
        nestedIterator = (NestedTypesIterator*)new BYTE[sizeOfIterator];
        nestedIterator->index = 0;
        nestedIterator->count = nestedCount;
        *iter = nestedIterator;
        pImport->GetNestedClasses(token, nestedIterator->tokens, nestedCount, &nestedCount);
    }

    if (nestedIterator->index < nestedIterator->count)
    {
        TypeHandle th = ClassLoader::LoadTypeDefThrowing(klass_clr->GetModule(),
            nestedIterator->tokens[nestedIterator->index],
            ClassLoader::ThrowIfNotFound,
            ClassLoader::PermitUninstDefOrRef);
        nestedIterator->index++;
        MONO_ASSERTE(!th.IsNull());
        return (MonoClass*)th.GetMethodTable();
    }
    else
    {
        *iter = NULL;
        delete[](BYTE*)nestedIterator;
    }

    return NULL;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_get_nesting_type(MonoClass *klass)
{
    MonoClass_clr* klass_clr = (MonoClass_clr*)klass;
    if (!klass_clr->GetClass()->IsNested())
    {
        return nullptr;
    }
    MonoClass_clr* ret = ClassLoader::LoadTypeDefOrRefOrSpecThrowing(klass_clr->GetModule(), klass_clr->GetEnclosingCl(), NULL, ClassLoader::ThrowIfNotFound, ClassLoader::PermitUninstDefOrRef).AsMethodTable();
    return (MonoClass*)ret;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_class_get_parent(MonoClass *klass)
{
    MonoClass_clr* parent = reinterpret_cast<MonoClass_clr*>(klass)->GetParentMethodTable();
    return (MonoClass*)parent;
}

extern "C" EXPORT_API MonoProperty* EXPORT_CC mono_class_get_property_from_name(MonoClass *klass, const char *name)
{
    // CoreCLR does not have easy support for iterating on properties on a MethodTable.
    // So instead, we look for the property's "get" method. This will not work for set-only
    // properties, but is sufficient for our needs for now.
    return (MonoProperty*)MemberLoader::FindPropertyMethod((MonoClass_clr*)klass, name, PropertyGet);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API int EXPORT_CC mono_class_get_rank(MonoClass* klass)
{
    return g_HostStruct->class_get_rank(klass);
}

extern "C" EXPORT_API MonoType* EXPORT_CC mono_class_get_type(MonoClass *klass)
{
    TypeHandle h(reinterpret_cast<MonoClass_clr*>(klass));
    return (MonoType*)h.AsPtr();
}

extern "C" EXPORT_API guint32 EXPORT_CC mono_class_get_type_token(MonoClass *klass)
{
    return (guint32)reinterpret_cast<MonoClass_clr*>(klass)->GetCl();
}

extern "C" EXPORT_API void* EXPORT_CC mono_class_get_userdata(MonoClass* klass)
{
    TRACE_API("%p", klass);

    CONTRACTL
    {
        NOTHROW;
    GC_NOTRIGGER;
    PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    return ((MonoClass_clr*)klass)->m_pUserData;
}

extern "C" EXPORT_API int EXPORT_CC mono_class_get_userdata_offset()
{
    //TRACE_API("", NULL);

    CONTRACTL
    {
        NOTHROW;
    GC_NOTRIGGER;
    }
    CONTRACTL_END;

    return offsetof(MethodTable, m_pUserData);
}

extern "C" EXPORT_API gint32 EXPORT_CC mono_class_instance_size(MonoClass *klass)
{
    return (guint32)reinterpret_cast<MonoClass_clr*>(klass)->GetNumInstanceFieldBytes() + sizeof(void*);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_blittable(MonoClass* klass)
{
    return g_HostStruct->class_is_blittable(klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_enum(MonoClass* klass)
{
    return g_HostStruct->class_is_enum(klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_generic(MonoClass* klass)
{
    return g_HostStruct->class_is_generic(klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_inflated(MonoClass* klass)
{
    return g_HostStruct->class_is_inflated(klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_subclass_of(MonoClass* klass, MonoClass* parent_class, gboolean check_interfaces)
{
    return g_HostStruct->class_is_subclass_of(klass, parent_class, check_interfaces);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_class_is_valuetype(MonoClass* klass)
{
    return g_HostStruct->class_is_valuetype(klass);
}

extern "C" EXPORT_API void EXPORT_CC mono_class_set_userdata(MonoClass* klass, void* userdata)
{
    TRACE_API("%p, %p", klass, userdata);

    CONTRACTL
    {
        NOTHROW;
    GC_NOTRIGGER;
    PRECONDITION(klass != NULL);
    }
    CONTRACTL_END;

    ((MonoClass_clr*)klass)->m_pUserData = userdata;
}

extern "C" EXPORT_API void EXPORT_CC mono_debug_free_source_location(MonoDebugSourceLocation* location)
{
}

extern "C" EXPORT_API MonoDebugSourceLocation* EXPORT_CC mono_debug_lookup_source_location(MonoMethod* method, guint32 address, MonoDomain* domain)
{
    ASSERT_NOT_IMPLEMENTED;
    return NULL;
}

extern "C" EXPORT_API void EXPORT_CC mono_debug_open_image_from_memory(MonoImage *image, const char *raw_contents, int size)
{
    // NOP
}

typedef void (*MonoDebuggerAttachFunc)(gboolean attached);
extern "C" EXPORT_API void EXPORT_CC mono_debugger_install_attach_detach_callback (MonoDebuggerAttachFunc func)
{
}

extern "C" EXPORT_API void EXPORT_CC mono_debugger_set_generate_debug_info(gboolean enable)
{
}

extern "C" EXPORT_API MonoAssembly* EXPORT_CC mono_domain_assembly_open(MonoDomain *domain, const char *name)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return (MonoAssembly*)g_HostStruct->load_assembly_from_path(name, (int32_t)strlen(name));;
}

struct MonoInternalCallFrame
{
    FrameWithCookie<HelperMethodFrame> frame;
    bool didSetupFrame;
};

// If this fails the size of MonoInternalCallFrameOpaque needs to be updted in MonoTypes.h in this repo and the Unity repo.
static_assert(sizeof(MonoInternalCallFrame) <= sizeof(MonoInternalCallFrameOpaque), "MonoInternalCallFrameOpaque needs to be larger");

// We currently need to wrap Unity icalls called from managed code mono_enter/exit_internal_call.
// This has two reasons:
// 1. We want to set up a CoreCLR stack frame for the icall to make call stack unwinding work
// (so we can get managed stack traces which cross native frames, as verified by the
// can_get_full_stack_trace_in_internal_method test).
// 2. We want to switch the thread to preemptive GC mode when running our icalls, to avoid delays and
// deadlocks when the GC waits for the icall to finish.
//
// Now, the problem is that this adds some overhead to calling icalls, which is not insignificant for
// small icalls (like Profiler.BeginSample). In most cases we can run icalls without wrapping them,
// but it is not generally safe to do so. So we need to find a solution to selectively wrap icalls
// only where needed.
extern "C" EXPORT_API void EXPORT_CC mono_enter_internal_call(MonoInternalCallFrameOpaque *_frame)
{
    TRACE_API("%x", _frame);

    FrameWithCookie<HelperMethodFrame>* frame = (FrameWithCookie<HelperMethodFrame>*)_frame;
    memset((void*)frame, 0, sizeof(MonoInternalCallFrame));
    new(frame) FrameWithCookie<HelperMethodFrame>(0, 0);

    // Should we set up the frame? We only need to do this when calling the icall from CoreCLR JITed code, but not when
    // calling it from Burst code (in which case GetThread() may not be valid if the worker thread is not attached).
    ((MonoInternalCallFrame*)_frame)->didSetupFrame = GetThread() != NULL && GetThread()->PreemptiveGCDisabled();

    // FCalls in CoreCLR always run in cooperative mode, as they are not written in a way which is
    // safe to use for the precice GC. However, for Unity ICalls (which use the same transition mechanism),
    // we cannot do that. Our icalls may often take non-trivial amounst of time, and in some cases use locking
    // mechanisms, which can cause a deadlock, if we need to wait for it to exit to start GC on another thread.
    // Because we disable the precise GC in Unity, we should be safe to interrupt our icalls for GC.
    if (((MonoInternalCallFrame*)_frame)->didSetupFrame)
    {
        INDEBUG(static BOOL __haveCheckedRestoreState = FALSE;)
        FORLAZYMACHSTATE_DEBUG_OK_TO_RETURN_BEGIN;
        FORLAZYMACHSTATE(CAPTURE_STATE(frame->MachineState(), return);)
        FORLAZYMACHSTATE_DEBUG_OK_TO_RETURN_END;
        INDEBUG(frame->SetAddrOfHaveCheckedRestoreState(&__haveCheckedRestoreState));
        frame->Push();

        GetThread()->EnablePreemptiveGC();
    }
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoException* EXPORT_CC mono_exception_from_name_msg(MonoImage* image, const char* name_space, const char* name, const char* msg)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->exception_from_name_msg(image, name_space, name, msg);
}


// If we enabled preemptive mode on icall enter we need to make sure we leave GC in preemptive modewhen detaching,
// so the thread can be further suspended by the GC at any point.
extern "C" EXPORT_API void EXPORT_CC mono_exit_internal_call(MonoInternalCallFrameOpaque *_frame)
{
    TRACE_API("%x", _frame);

    FrameWithCookie<HelperMethodFrame>* frame = (FrameWithCookie<HelperMethodFrame>*)_frame;

    if (((MonoInternalCallFrame*)_frame)->didSetupFrame)
    {
        GetThread()->DisablePreemptiveGC();
        frame->Pop();
    }
    frame->~FrameWithCookie<HelperMethodFrame>();
}

extern "C" EXPORT_API guint32 EXPORT_CC mono_field_get_flags(MonoClassField *field)
{
    return ((FieldDesc*)field)->GetAttributes();
}

extern "C" EXPORT_API const char* EXPORT_CC mono_field_get_name(MonoClassField *field)
{
    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        MODE_ANY;
    }
    CONTRACTL_END
    auto field_clr = (MonoClassField_clr*)field;
    return field_clr->GetName();
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoReflectionField* EXPORT_CC mono_field_get_object(MonoDomain* domain, MonoClass* klass, MonoClassField* field)
{
    return g_HostStruct->field_get_object(domain, klass, field);
}

extern "C" EXPORT_API int EXPORT_CC mono_field_get_offset(MonoClassField *field)
{
    TRACE_API("%p", field);

    auto field_clr = (MonoClassField_clr*)field;
    if (field_clr->IsStatic())
    {
        return 0;
    }

    auto result = field_clr->GetOffset();
    result += sizeof(Object);

    return result;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_field_get_parent(MonoClassField *field)
{
    FieldDesc* fieldDesc = (FieldDesc*)field;
    return (MonoClass*)fieldDesc->GetApproxEnclosingMethodTable();
}

extern "C" EXPORT_API MonoType* EXPORT_CC mono_field_get_type(MonoClassField *field)
{
    CONTRACTL
    {
        PRECONDITION(field != NULL);
    }
    CONTRACTL_END;

    auto field_clr = (MonoClassField_clr*)field;

    MonoType_clr typeHandle = field_clr->GetFieldTypeHandleThrowing();

    return MonoType_clr_to_MonoType(typeHandle);
}

extern "C" EXPORT_API MonoType* EXPORT_CC mono_field_get_type_specific(MonoClassField *field, MonoClass* owner)
{
    CONTRACTL
    {
        PRECONDITION(field != NULL);
    }
    CONTRACTL_END;

    auto field_clr = (MonoClassField_clr*)field;
    auto klass_clr = (MonoClass_clr*)owner;

    MonoType_clr typeHandle = field_clr->GetExactFieldType(klass_clr);

    return MonoType_clr_to_MonoType(typeHandle);
}

extern "C" EXPORT_API void EXPORT_CC mono_gc_collect(int generation)
{
    FCALL_CONTRACT;
    _ASSERTE(generation >= -1);
    GCX_COOP();
    GCHeapUtilities::GetGCHeap()->GarbageCollect(generation, false, collection_blocking);
}

extern "C" EXPORT_API int EXPORT_CC mono_gc_collect_a_little ()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API gint64 EXPORT_CC mono_gc_get_max_time_slice_ns ()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gint64 EXPORT_CC mono_gc_get_used_size()
{
    return g_HostStruct->gc_get_used_size();
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_gc_is_incremental ()
{
    return false;
}

extern "C" EXPORT_API void EXPORT_CC mono_gc_set_incremental (gboolean value)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_gc_set_max_time_slice_ns (gint64 maxTimeSlice)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_gc_wbarrier_set_field (MonoObject * obj, gpointer field_ptr, MonoObject * value)
{
    GCX_COOP();

    SetObjectReference((OBJECTREF*)field_ptr, ObjectToOBJECTREF((MonoObject_clr*)value));
}

static inline OBJECTHANDLE handle_from_uintptr(uintptr_t p)
{
    // mask off bit that is set for pinned in managed
    p &= (~(uintptr_t)1);
    return (OBJECTHANDLE)p;
}

static inline uintptr_t handle_to_uintptr(OBJECTHANDLE h, bool pinned)
{
    uintptr_t p = (uintptr_t)h;
    // managed code expects lowest bit set for pinned handles
    if (pinned)
        p |= (uintptr_t)1;
    return p;
}

extern "C" EXPORT_API void EXPORT_CC mono_gchandle_free_v2(uintptr_t gchandle)
{
    OBJECTHANDLE objectHandle = handle_from_uintptr(gchandle);

    GCHandleUtilities::GetGCHandleManager()->DestroyHandleOfUnknownType(objectHandle);
}

extern "C" EXPORT_API MonoImage* EXPORT_CC mono_get_corlib()
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->get_corlib();
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_get_enum_class()
{
    MonoImage* img = mono_get_corlib();
    return mono_class_from_name(img, "System", "Enum");
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoException* EXPORT_CC mono_get_exception_argument_null(const char* arg)
{
    return g_HostStruct->get_exception_argument_null(arg);
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_get_object_class()
{
    return (MonoClass*)CoreLibBinder::GetClass(CLASS__OBJECT);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API const char* EXPORT_CC mono_image_get_filename(MonoImage* image)
{
    return g_HostStruct->image_get_filename(image);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API const char* EXPORT_CC mono_image_get_name(MonoImage* image)
{
    return g_HostStruct->image_get_name(image);
}

static ASSEMBLYREF ASSEMBLYREF_From_AssemblyIntPtrHandle(MonoImage* assemblyIntPtrHandle)
{
    OBJECTHANDLE assemblyHandle = handle_from_uintptr((uintptr_t)assemblyIntPtrHandle);
    OBJECTREF assemblyObjectRef = ObjectFromHandle(assemblyHandle);
    return ASSEMBLYREF(assemblyObjectRef);
}

extern "C" EXPORT_API int32_t EXPORT_CC mono_image_get_table_rows(MonoImage* assemblyIntPtrHandle, int32_t table_token)
{
    CONTRACTL
    {
        NOTHROW;
        GC_NOTRIGGER;
        MODE_ANY;
    }
    CONTRACTL_END;

    GCX_COOP();

    ASSEMBLYREF assemblyRef = ASSEMBLYREF_From_AssemblyIntPtrHandle(assemblyIntPtrHandle);
    return assemblyRef->GetAssembly()->GetMDImport()->GetCountWithTokenKind(table_token);
}

extern "C" EXPORT_API void EXPORT_CC mono_assembly_get_assemblyref(MonoImage* assemblyIntPtrHandle, int32_t idx, MonoAssemblyName* aname)
{
    CONTRACTL
    {
        NOTHROW;
        GC_NOTRIGGER;
        MODE_ANY;
    }
    CONTRACTL_END;

    GCX_COOP();

    ASSEMBLYREF assemblyRef = ASSEMBLYREF_From_AssemblyIntPtrHandle(assemblyIntPtrHandle);

    // Only extract the assembly name
    DWORD token = TokenFromRid(idx, mdtAssemblyRef);
    assemblyRef->GetAssembly()->GetMDImport()->GetAssemblyRefProps(token, NULL, NULL, &aname->name, NULL, NULL, NULL, NULL);
}

extern "C" EXPORT_API void EXPORT_CC coreclr_image_get_custom_attribute_data(MonoImage* assemblyIntPtrHandle, int idx, guint32* type_token, guint32* parent_type_token)
{
    CONTRACTL
    {
        NOTHROW;
        GC_NOTRIGGER;
        MODE_ANY;
    }
    CONTRACTL_END;

    GCX_COOP();

    ASSEMBLYREF assemblyRef = ASSEMBLYREF_From_AssemblyIntPtrHandle(assemblyIntPtrHandle);
    IMDInternalImport* mdImport = assemblyRef->GetAssembly()->GetMDImport();

    DWORD token = TokenFromRid(idx + 1, mdtCustomAttribute);
    *type_token = 0;
    *parent_type_token = 0;

    mdImport->GetCustomAttributeProps(token, type_token);
    mdImport->GetParentToken(token, parent_type_token);
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_unity_class_get(MonoImage* image, guint32 token)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_class_get(image, token);
}

extern "C" EXPORT_API MonoMethod* EXPORT_CC mono_get_method(MonoImage* image, guint32 token, MonoClass* klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->get_method(image, token, klass);
}

extern "C" EXPORT_API MonoClassField* EXPORT_CC mono_field_from_token (MonoImage * image, uint32_t token, MonoClass** retklass, MonoGenericContext * context)
{
    if (context != nullptr)
    {
        ASSERT_NOT_IMPLEMENTED;
        return NULL;
    }

    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_field_from_token_checked(image, token, retklass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoImage* EXPORT_CC mono_image_loaded(const char* name)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->image_loaded(name);
}

extern "C" EXPORT_API MonoImage* EXPORT_CC mono_image_open_from_data_with_name(char *data, guint32 data_len, gboolean need_copy, int *status, gboolean refonly, const char *name)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    gint64 len = data_len;
    return (MonoImage*)g_HostStruct->load_assembly_from_data(data, len);
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_is_debugger_attached(void)
{
    return FALSE;
}

extern "C" EXPORT_API MonoJitInfo* EXPORT_CC mono_jit_info_table_find(MonoDomain* domain, void* ip)
{
    ASSERT_NOT_IMPLEMENTED;
    return NULL;
}

extern "C" EXPORT_API MonoDomain* EXPORT_CC mono_jit_init(const char *file)
{
    TRACE_API("%s", file);

    return mono_jit_init_version(file, "4.0");
}

typedef int32_t (*initialize_scripting_runtime_func)();
typedef int32_t (*initialize_func)(HostStruct* s, int32_t size, HostStructNative* n, int32_t sizeNative);
typedef void (*unity_log_func)(const char* format);

void list_tpa(const SString& searchPath, SString& tpa)
{
    SString searchPattern = searchPath;
    searchPattern += W("/*.dll");
    WIN32_FIND_DATAW findData;
    HANDLE fileHandle = FindFirstFileW(searchPattern.GetUnicode(), &findData);

    if (fileHandle != INVALID_HANDLE_VALUE)
    {
        do
        {
            tpa.Append(searchPath);
            tpa.Append(W("/"));
            tpa.Append(findData.cFileName);
            tpa += PATH_SEPARATOR;
        } while (FindNextFileW(fileHandle, &findData));
        FindClose(fileHandle);
    }
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_initialize_host_apis(initialize_func init_func)
{
    HRESULT hr;
    g_HostStruct = (HostStruct*)malloc(sizeof(HostStruct));
    memset(g_HostStruct, 0, sizeof(HostStruct));

    g_HostStructNative = (HostStructNative*)malloc(sizeof(HostStructNative));
    memset(g_HostStructNative, 0, sizeof(HostStructNative));

    g_HostStructNative->unity_log = (unity_log_func)&unity_log;
    g_HostStructNative->return_handles_from_api = &return_handles_from_api;

    hr = init_func(g_HostStruct, (int32_t)sizeof(HostStruct), g_HostStructNative, (int32_t)sizeof(HostStructNative));

    AppDomain *pCurDomain = SystemDomain::GetCurrentDomain();

    // Disable Windows message processing during waits
    // On Windows by default waits will processing some messages (COM, WM_PAINT, ...) leading to reentrancy issues
    pCurDomain->SetForceTrivialWaitOperations();

    gRootDomain = gCurrentDomain = (MonoDomain*)pCurDomain;
}

extern "C" EXPORT_API MonoDomain* EXPORT_CC mono_jit_init_version(const char *file, const char* runtime_version)
{
    gboolean useRealGC = false;
    if (runtime_version != NULL)
    {
        if (strstr(runtime_version, "return-handles-from-api"))
            s_ReturnHandlesFromAPI = true;
        if (strstr(runtime_version, "use-real-gc"))
        {
            useRealGC = true;
            s_ReturnHandlesFromAPI = true;
        }
    }

    if (!useRealGC)
    {
    #if defined(TARGET_UNIX)
#if defined(__APPLE__)
        GCHeapUtilities::SetGCName("libunitygc.dylib");
#else
        GCHeapUtilities::SetGCName("libunitygc.so");
#endif
#else
        GCHeapUtilities::SetGCName("unitygc.dll");
#endif
    }

    g_add_internal_lock.Init(CrstLeafLock);

    HRESULT hr;

    if (!g_CLRRuntimeHost)
    {
        const char* entrypointExecutable = "/dev/null";
#if defined(__APPLE__) || defined(__linux__)
        uint32_t lenActualPath = 0;
        /*if (_NSGetExecutablePath(nullptr, &lenActualPath) == -1)
        {
            // OSX has placed the actual path length in lenActualPath,
            // so re-attempt the operation
            entrypointExecutable = new char[lenActualPath + 1];
            entrypointExecutable[lenActualPath] = '\0';
            if (_NSGetExecutablePath(entrypointExecutable, &lenActualPath) == -1)
            {
                delete [] entrypointExecutable;
                return nullptr;
            }
        }
        else
        {
            return nullptr;
        }*/
#endif

        SString appPath (*s_AssemblyDir);

        SString etcPath (*s_EtcDir);

        SString tpa;
        list_tpa(appPath, tpa);

        SString appPaths;
        appPaths += appPath;
        if (s_AssemblyPaths != NULL)
        {
            appPaths += PATH_SEPARATOR;
            appPaths += *s_AssemblyPaths;
        }

        SString appNiPaths;
        appNiPaths += appPath;
        appNiPaths+= PATH_SEPARATOR;
        appNiPaths += appPath;

        SString nativeDllSearchDirs;
        nativeDllSearchDirs += appPath;
        nativeDllSearchDirs += PATH_SEPARATOR;
        nativeDllSearchDirs += etcPath;

        LPCSTR property_keys2[] = {
            "TRUSTED_PLATFORM_ASSEMBLIES",
            "APP_PATHS",
            "APP_NI_PATHS",
            "NATIVE_DLL_SEARCH_DIRECTORIES"
        };

        LPCSTR property_values2[] = {
                  tpa.GetUTF8(),
                  appPaths.GetUTF8(),
                  appNiPaths.GetUTF8(),
                  nativeDllSearchDirs.GetUTF8()
        };

        hr = coreclr_initialize (entrypointExecutable, file, 4, property_keys2, property_values2, &g_CLRRuntimeHost, &g_RootDomainId);

        if(FAILED(hr))
        {
            return nullptr;
        }
    }

    initialize_func init_func;
    hr = coreclr_create_delegate(g_CLRRuntimeHost, g_RootDomainId, "unity-embed-host", "Unity.CoreCLRHelpers.CoreCLRHost", "InitMethod", (void**)&init_func);
    if(FAILED(hr))
    {
        return nullptr;
    }

    mono_unity_initialize_host_apis(init_func);

    // Note : This logic can be removed once the switch over to using unity_coreclr_create_delegate is complete
    initialize_scripting_runtime_func init_runtime_func;
    hr = coreclr_create_delegate(g_CLRRuntimeHost, g_RootDomainId, "UnityEngine.Scripting", "UnityEngine.Scripting.Initialization", "NativeCallbackToPerformInitialization", (void**)&init_runtime_func);
    if (hr == 0)
    {
        init_runtime_func();
    }

    //coreClrHelperAssembly->EnsureActive();
    //gCoreCLRHelperAssembly = (MonoImage*)coreClrHelperAssembly;

    //gRootDomain = gCurrentDomain;

/*
    FrameWithCookie<GCNativeFrame>* frame = (FrameWithCookie<GCNativeFrame>*)malloc(sizeof(FrameWithCookie<GCNativeFrame>));
    new (frame) FrameWithCookie<GCNativeFrame> ();
    pCurrentThreadNativeFrame = &(*frame);
    frame->Push();*/


    TRACE_API("%s, %s", file, runtime_version);
    return gCurrentDomain;
}

// This is a stop gap helper to assist with scripting core initializing itself until the entirety of coreclr initialization can be moved
// into scripting core.
extern "C" EXPORT_API void* EXPORT_CC unity_coreclr_create_delegate(const char* assemblyName, const char* typeName, const char* methodName)
{
    void* func;
    HRESULT hr = coreclr_create_delegate(g_CLRRuntimeHost, g_RootDomainId, assemblyName, typeName, methodName, (void**)&func);
    if(FAILED(hr))
    {
        return nullptr;
    }

    return (void*)func;
}

extern "C" EXPORT_API void EXPORT_CC mono_jit_parse_options(int argc, char * argv[])
{
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_metadata_signature_equal(MonoMethodSignature *sig1, MonoMethodSignature *sig2)
{
    if (mono_signature_get_param_count(sig1) != mono_signature_get_param_count(sig2))
        return FALSE;
    if (mono_signature_get_return_type(sig1) != mono_signature_get_return_type(sig2))
        return FALSE;
    if (mono_signature_is_instance(sig1) != mono_signature_is_instance(sig2))
        return FALSE;

    gpointer iter1 = NULL;
    gpointer iter2 = NULL;
    bool match = true;
    while (MonoType *paramType1 = mono_signature_get_params(sig1, &iter1))
    {
        MonoType *paramType2 = mono_signature_get_params(sig2, &iter2);
        if (paramType1 != paramType2)
            match = false;
    }
    return match;
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_metadata_type_equal (MonoType * t1, MonoType * t2)
{
    MonoType_clr* type1 = (MonoType_clr*)t1;
    MonoType_clr* type2 = (MonoType_clr*)t2;
    return type1->IsEquivalentTo(*type2);
}

extern "C" EXPORT_API char* EXPORT_CC mono_method_full_name(MonoMethod* method, gboolean signature)
{
    auto methodclr = reinterpret_cast<MonoMethod_clr*>(method);
 	LPCUTF8 name, namespaze;
    auto mt = methodclr->GetMethodTable();
	mt->GetMDImport()->GetNameOfTypeDef(mt->GetCl(), &name, &namespaze);

    InlineSString<256> fullName(SString::Utf8);
    if (namespaze != NULL)
    {
        fullName += InlineSString<256>(SString::Utf8, namespaze);
        fullName += '.';
    }
    fullName += InlineSString<256>(SString::Utf8, name);
    fullName += ':';
    fullName +=  InlineSString<256>(SString::Utf8, methodclr->GetName());

    if (signature)
    {
        fullName += InlineSString<2>(SString::Utf8, " (");

        MonoMethodSignature* sig = mono_method_signature(method);
        gpointer iter = NULL;

        MonoType *paramType = mono_signature_get_params(sig, &iter);
        if (paramType)
        {
            fullName += InlineSString<256>(SString::Utf8, mono_type_get_name(paramType));
            while ((paramType = mono_signature_get_params(sig, &iter)))
            {
                fullName += ',';
                fullName += InlineSString<256>(SString::Utf8, mono_type_get_name(paramType));
            }
        }

        fullName += ')';
    }
    return _strdup(fullName.GetUTF8());
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_method_get_class(MonoMethod *method)
{
    auto method_clr = (MonoMethod_clr*)method;
    auto class_clr = (MonoClass_clr*)method_clr->GetClass()->GetMethodTable();
    return (MonoClass*)class_clr;
}

extern "C" EXPORT_API MonoMethod* EXPORT_CC mono_method_get_last_managed()
{
    return (MonoMethod*)(intptr_t)g_isManaged;
}

extern "C" EXPORT_API const char* EXPORT_CC mono_method_get_name(MonoMethod *method)
{
    return reinterpret_cast<MonoMethod_clr*>(method)->GetName();
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoReflectionMethod* EXPORT_CC mono_method_get_object(MonoDomain* domain, MonoMethod* method, MonoClass* refclass)
{
    return g_HostStruct->method_get_object(domain, method, refclass);
}

extern "C" EXPORT_API MonoMethodSignature* EXPORT_CC mono_method_signature(MonoMethod *method)
{
    return (MonoMethodSignature*)method;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoClass* EXPORT_CC mono_object_get_class(MonoObject* obj)
{
    return g_HostStruct->object_get_class(obj);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoMethod* EXPORT_CC mono_object_get_virtual_method(MonoObject* obj, MonoMethod* method)
{
    return g_HostStruct->object_get_virtual_method(obj, method);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_object_isinst(MonoObject* obj, MonoClass* klass)
{
    return g_HostStruct->object_isinst(obj, klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_object_new(MonoDomain* domain, MonoClass* klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->object_new(domain, klass);
}

extern "C" EXPORT_API void* EXPORT_CC mono_profiler_create (MonoProfiler* prof)
{
    ASSERT_NOT_IMPLEMENTED;
    return NULL;
}

extern "C" EXPORT_API void EXPORT_CC mono_profiler_install(void *prof, MonoProfileFunc shutdown_callback)
{
    // NOP
}

extern "C" EXPORT_API void EXPORT_CC mono_profiler_install_thread(MonoProfileThreadFunc start, MonoProfileThreadFunc end)
{
    // NOP
}

extern "C" EXPORT_API void EXPORT_CC mono_profiler_load (const char *desc)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_profiler_set_events(int events)
{
    // NOP
}


extern "C" EXPORT_API MonoMethod* EXPORT_CC mono_property_get_get_method(MonoProperty *prop)
{
    return (MonoMethod*)prop;
}

extern "C" EXPORT_API void EXPORT_CC mono_raise_exception(MonoException *ex)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API MonoObject* EXPORT_CC mono_runtime_invoke(MonoMethod *method, void *obj, void **params, MonoException **exc)
{
    TRACE_API("%p, %p, %p, %p", method, obj, params, exc);

    if (obj == nullptr)
        return mono_runtime_invoke_with_nested_object(method, nullptr, nullptr, params, exc);
    MonoClass_clr * klass = (MonoClass_clr*)mono_object_get_class((MonoObject*)obj);
    auto method_clr = (MonoMethod_clr*)method;
    if (klass->IsValueType())// && !method_clr->IsVtableMethod())
        return mono_runtime_invoke_with_nested_object(method, (char*)obj + sizeof(Object), obj, params, exc);
    else
        return mono_runtime_invoke_with_nested_object(method, obj, obj, params, exc);
}

extern "C" EXPORT_API MonoObject* EXPORT_CC mono_runtime_invoke_with_nested_object(MonoMethod *method, void *obj, void *parentobj, void **params, MonoException **exc)
{
    TRACE_API("%p, %p, %p, %p, %p", method, obj, parentobj, params, exc);

    GCX_COOP();

    auto method_clr = (MonoMethod_clr*)method;

    MetaSig     methodSig(method_clr);
    DWORD numArgs = methodSig.NumFixedArgs();
    ArgIterator argIt(&methodSig);

    const int MAX_ARG_SLOT = 128;
    ARG_SLOT argslots[MAX_ARG_SLOT];

    DWORD slotIndex = 0;
    if (methodSig.HasThis())
    {
        if (obj != parentobj && method_clr->IsVtableMethod())
            obj = (char*)obj - sizeof(Object) ;
        argslots[0] = PtrToArgSlot(obj);
        slotIndex++;
    }

    PVOID pRetBufStackCopy = NULL;
    auto retTH = methodSig.GetRetTypeHandleNT();
    CorElementType retType = retTH.GetInternalCorElementType();

    auto hasReturnBufferArg = argIt.HasRetBuffArg();
    if (hasReturnBufferArg)
    {
        SIZE_T sz = retTH.GetMethodTable()->GetNumInstanceFieldBytes();
        pRetBufStackCopy = _alloca(sz);
        memset(pRetBufStackCopy, 0, sz);
        argslots[slotIndex] = PtrToArgSlot(pRetBufStackCopy);
        slotIndex++;
    }

    for (DWORD argIndex = 0; argIndex < numArgs; argIndex++, slotIndex++)
    {
        int ofs = argIt.GetNextOffset();
        _ASSERTE(ofs != TransitionBlock::InvalidOffset);
        auto stackSize = argIt.GetArgSize();

        auto argTH = methodSig.GetLastTypeHandleNT();
        auto argType = argTH.GetInternalCorElementType();

        // TODO: Factorize ValueType detection and Managed detection
        switch (argType)
        {
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_BOOLEAN:      // boolean
        case ELEMENT_TYPE_I1:           // byte
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:           // short
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:         // char
        case ELEMENT_TYPE_I4:           // int
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:           // long
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R4:           // float
        case ELEMENT_TYPE_R8:           // double
        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_U:
            switch (stackSize)
            {
            case 1:
            case 2:
            case 4:
                argslots[slotIndex] = *(INT32*)params[argIndex];
                break;

            case 8:
                argslots[slotIndex] = *(INT64*)params[argIndex];
                break;

            default:
                if (stackSize > sizeof(ARG_SLOT))
                {
                    argslots[slotIndex] = PtrToArgSlot(params[argIndex]);
                }
                else
                {
                    CopyMemory(&argslots[slotIndex], params[argIndex], stackSize);
                }
                break;
            }
            break;
        case ELEMENT_TYPE_BYREF:
            argslots[slotIndex] = PtrToArgSlot(params[argIndex]);
            break;
        case ELEMENT_TYPE_PTR:
            argslots[slotIndex] = PtrToArgSlot(params[argIndex]);
            break;
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_VAR:
            argslots[slotIndex] = ObjToArgSlot(ObjectToOBJECTREF((MonoObject_clr*)params[argIndex]));
            break;
        default:
            assert(false && "This argType is not supported");
            break;
        }
    }

    // TODO: Convert params to ARG_SLOT

    g_isManaged++;
    ARG_SLOT result = NULL;
    EX_TRY
    {
        MonoClass_clr * klass = (MonoClass_clr*)mono_method_get_class(method);

        OBJECTREF objref = ObjectToOBJECTREF((Object*)parentobj);
        MethodDescCallSite invoker((MonoMethod_clr*)method, &objref);
        result = invoker.Call_RetArgSlot(argslots);
    }
    EX_CATCH
    {
        SString sstr;
        GET_EXCEPTION()->GetMessage(sstr);
        printf("Exception calling %s: %s\n", mono_method_get_name(method), sstr.GetUTF8());
        fflush(stdout);

        if (exc && GET_EXCEPTION()->IsType(CLRException::GetType()))
            *exc = (MonoException*)OBJECTREFToObject(((CLRException*)GET_EXCEPTION())->GetThrowable());
    }
    EX_END_CATCH(SwallowAllExceptions)
    g_isManaged--;

    methodSig.Reset();
    if (methodSig.IsReturnTypeVoid())
    {
        return nullptr;
    }

    // Check reflectioninvocation.cpp
    // TODO: Handle
    switch (retType)
    {
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_BOOLEAN:      // boolean
        case ELEMENT_TYPE_I1:           // byte
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:           // short
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:         // char
        case ELEMENT_TYPE_I4:           // int
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:           // long
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R4:           // float
        case ELEMENT_TYPE_R8:           // double
        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_PTR:
            if (hasReturnBufferArg)
            {
                return (MonoObject*)OBJECTREFToObject(retTH.GetMethodTable()->Box(pRetBufStackCopy));
            }
            else
            {
                return (MonoObject*)OBJECTREFToObject(retTH.GetMethodTable()->Box(&result));
            }
            break;
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_VAR:
            return (MonoObject*)OBJECTREFToObject(ArgSlotToObj(result));
            break;
        default:
            assert(false && "This retType is not supported");
            break;
    }
    return nullptr;
}

extern "C" EXPORT_API void EXPORT_CC mono_set_assemblies_path(const char* name)
{
    s_AssemblyPaths = new SString(SString::Utf8, name);
}

extern "C" EXPORT_API void EXPORT_CC mono_set_assemblies_path_null_separated (const char* name)
{
    s_AssemblyPaths = new SString();
    while (*name != NULL)
    {
        size_t l = strlen(name);
        s_AssemblyPaths->AppendUTF8(name);
        s_AssemblyPaths->AppendUTF8(PATH_SEPARATOR);
        name += l+1;
    }
}

extern "C" EXPORT_API void EXPORT_CC mono_set_dirs(const char *assembly_dir, const char *config_dir)
{
    s_AssemblyDir = new SString(SString::Utf8, assembly_dir);
    s_EtcDir = new SString(SString::Utf8, config_dir);
}

extern "C" EXPORT_API guint32 EXPORT_CC mono_signature_get_param_count(MonoMethodSignature *sig)
{
    MonoMethodSignature_clr* msig = (MonoMethodSignature_clr*)sig;
    MetaSig metasig(msig);
    return metasig.NumFixedArgs();
}

extern "C" EXPORT_API MonoType* EXPORT_CC mono_signature_get_params(MonoMethodSignature *sig, gpointer *iter)
{
    MonoMethodSignature_clr* signature = (MonoMethodSignature_clr*)sig;
    MetaSig* metasig = (MetaSig*)*iter;
    if (metasig == NULL)
    {
        metasig = new MetaSig(signature);
        *iter = metasig;
    }

    CorElementType argType = metasig->NextArg();
    if (argType == ELEMENT_TYPE_END)
    {
        delete metasig;
        //*iter = NULL; // match mono behavior
        return NULL;
    }

    TypeHandle typeHandle = metasig->GetLastTypeHandleThrowing();
    return (MonoType*)typeHandle.AsPtr();
}

extern "C" EXPORT_API MonoType* EXPORT_CC mono_signature_get_return_type(MonoMethodSignature *sig)
{
    MonoMethodSignature_clr* signature = (MonoMethodSignature_clr*)sig;
    MetaSig msig(signature);
    TypeHandle reth = msig.GetRetTypeHandleThrowing();
    return (MonoType*)reth.AsPtr();
}

extern "C" EXPORT_API char EXPORT_CC mono_signature_is_instance(MonoMethodSignature *sig)
{
    MonoMethodSignature_clr* sig_clr = (MonoMethodSignature_clr*)sig;
    MetaSig msig(sig_clr);
    return (char)msig.HasThis();
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoString* EXPORT_CC mono_string_from_utf16(const gunichar2* text)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return (MonoString*)g_HostStruct->string_from_utf16(text);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoString* EXPORT_CC mono_string_new_len(MonoDomain* domain, const char* text, guint32 length)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return (MonoString*)g_HostStruct->string_new_len(domain, text, length);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoString* EXPORT_CC mono_string_new_utf16(MonoDomain* domain, const guint16* text, gint32 length)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return (MonoString*)g_HostStruct->string_new_utf16(domain, text, length);
}

extern "C" EXPORT_API MonoString* EXPORT_CC mono_string_new_wrapper(const char* text)
{
    return mono_string_new_len(nullptr, text, (guint32)strlen(text));
}

extern "C" EXPORT_API MonoThread* EXPORT_CC mono_thread_attach(MonoDomain *domain)
{
    MonoThread_clr* currentThread = GetThreadNULLOk();

    if (currentThread == nullptr)
    {
        currentThread = SetupThreadNoThrow();
    }

    assert(currentThread != nullptr);
    gCurrentDomain = domain;

    return (MonoThread*)currentThread;
}

extern "C" EXPORT_API MonoThread* EXPORT_CC mono_thread_current(void)
{
    return (MonoThread*)GetThread();
}

extern "C" EXPORT_API void EXPORT_CC mono_thread_detach(MonoThread *thread)
{
    CONTRACTL{
        PRECONDITION(thread != nullptr);
    } CONTRACTL_END;
    auto thread_clr = (MonoThread_clr*)thread;
    gCurrentDomain = NULL;
    // TODO: FALSE or TRUE there?
    thread_clr->DetachThread(FALSE);
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_thread_has_sufficient_execution_stack (void)
{
    // TODO: Investigate if we need to implement this
    return TRUE;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_type_get_class(MonoType *type)
{
    TypeHandle handle = TypeHandle::FromPtr((PTR_VOID)type);
    return (MonoClass*)handle.AsMethodTable();
}

extern "C" EXPORT_API char* EXPORT_CC mono_type_get_name(MonoType *type)
{
    // To be compatible with Mono behavior.
    return mono_type_get_name_full(type, MonoTypeNameFormat::MONO_TYPE_NAME_FORMAT_IL);
}

// The method can be moved to C# code, but will require introduction
// of core_clr_FreeHGlobal method to properly free an allocated string
extern "C" EXPORT_API char* EXPORT_CC mono_type_get_name_full(MonoType *type, MonoTypeNameFormat monoFormat)
{
    TRACE_API("%p %d", type, format);

    DWORD format = TypeString::FormatBasic;
    switch (monoFormat)
    {
        case MonoTypeNameFormat::MONO_TYPE_NAME_FORMAT_IL:
            // The closest managed equivalent is Type.ToString()
            format = TypeString::FormatNamespace;
            break;
        case MonoTypeNameFormat::MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED:
            // The managed equivalent is Type.AssemblyQualifiedName
            format = TypeString::FormatNamespace | TypeString::FormatAssembly | TypeString::FormatFullInst;
            break;

        default:
            ASSERT_NOT_IMPLEMENTED;
            return NULL;
    }

    TypeHandle handle = TypeHandle::FromPtr((PTR_VOID)type);
    SString ssBuf;
    TypeString::AppendType(ssBuf, handle, format);

    return _strdup(ssBuf.GetUTF8());
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_type_get_object(MonoDomain* domain, MonoType* type)
{
    return g_HostStruct->type_get_object(domain, type);
}

extern "C" EXPORT_API int EXPORT_CC mono_type_get_type(MonoType *type)
{
retry:

    if (type == mono_class_get_type((MonoClass*)CoreLibBinder::GetClass(CLASS__STRING)))
        return MONO_TYPE_STRING;
    if (type == mono_class_get_type(mono_get_object_class()))
        return MONO_TYPE_OBJECT;

    TypeHandle typeHandle = TypeHandle::FromPtr((PTR_VOID)type);

    // TODO: not sure this is correct, but without this
    // generic instance types map to MONO_TYPE_CLASS
    if (typeHandle.HasInstantiation())
        return MONO_TYPE_GENERICINST;

    // TODO: Different behavior than mono
    // It seems that CLR is collapsing type like
    // ELEMENT_TYPE_OBJECT into ELEMENT_TYPE_CLASS
    auto elementType = typeHandle.GetVerifierCorElementType();

    switch(elementType)
    {
        case ELEMENT_TYPE_VOID:
            return MONO_TYPE_VOID;
        case ELEMENT_TYPE_END:
            return MONO_TYPE_END;
        case ELEMENT_TYPE_PTR:
            return MONO_TYPE_PTR;
        case ELEMENT_TYPE_BYREF:
            // mono exposes this as the underlying type
            type =  (MonoType*)typeHandle.GetTypeParam().AsPtr();
            goto retry;
            //return MONO_TYPE_BYREF;
        case ELEMENT_TYPE_STRING:
            return MONO_TYPE_STRING;
        case ELEMENT_TYPE_R4:
            return MONO_TYPE_R4;
        case ELEMENT_TYPE_R8:
            return MONO_TYPE_R8;
        case ELEMENT_TYPE_I8:
            return MONO_TYPE_I8;
        case ELEMENT_TYPE_I4:
            return MONO_TYPE_I4;
        case ELEMENT_TYPE_I2:
            return MONO_TYPE_I2;
        case ELEMENT_TYPE_I1:
            return MONO_TYPE_I1;
        case ELEMENT_TYPE_U8:
            return MONO_TYPE_U8;
        case ELEMENT_TYPE_U4:
            return MONO_TYPE_U4;
        case ELEMENT_TYPE_U2:
            return MONO_TYPE_U2;
        case ELEMENT_TYPE_U1:
            return MONO_TYPE_U1;
        case ELEMENT_TYPE_CLASS:
            return MONO_TYPE_CLASS;
        case ELEMENT_TYPE_BOOLEAN:
            return MONO_TYPE_BOOLEAN;
        case ELEMENT_TYPE_CHAR:
            return MONO_TYPE_CHAR;
        case ELEMENT_TYPE_VALUETYPE:
            return MONO_TYPE_VALUETYPE;
        case ELEMENT_TYPE_VAR:
            return MONO_TYPE_VAR;
        case ELEMENT_TYPE_ARRAY:
            return MONO_TYPE_ARRAY;
        case ELEMENT_TYPE_GENERICINST:
            return MONO_TYPE_GENERICINST;
        case ELEMENT_TYPE_TYPEDBYREF:
            return MONO_TYPE_TYPEDBYREF;
        case ELEMENT_TYPE_I:
            return MONO_TYPE_I;
        case ELEMENT_TYPE_U:
            return MONO_TYPE_U;
        case ELEMENT_TYPE_FNPTR:
            return MONO_TYPE_FNPTR;
        case ELEMENT_TYPE_OBJECT:
            return MONO_TYPE_OBJECT;
        case ELEMENT_TYPE_SZARRAY:
            return MONO_TYPE_SZARRAY;
        case ELEMENT_TYPE_MVAR:
            return MONO_TYPE_MVAR;
        case ELEMENT_TYPE_CMOD_REQD:
            return MONO_TYPE_CMOD_REQD;
        case ELEMENT_TYPE_CMOD_OPT:
            return MONO_TYPE_CMOD_OPT;
        case ELEMENT_TYPE_INTERNAL:
            return MONO_TYPE_INTERNAL;
        case ELEMENT_TYPE_MODIFIER:
            return MONO_TYPE_MODIFIER;
        case ELEMENT_TYPE_SENTINEL:
            return MONO_TYPE_SENTINEL;
        case ELEMENT_TYPE_PINNED:
            return MONO_TYPE_PINNED;
        default:
            return 0;
    }
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_type_is_byref (MonoType * type)
{
    TypeHandle clrType = TypeHandle::FromPtr(reinterpret_cast<PTR_VOID>(type));
    return clrType.IsByRef();
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_allocation_granularity ()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoArray* EXPORT_CC mono_unity_array_new_2d(MonoDomain* domain, MonoClass* klass, size_t size0, size_t size1)
{
    return g_HostStruct->unity_array_new_2d(domain, klass, size0, size1);
}


// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoArray* EXPORT_CC mono_unity_array_new_3d(MonoDomain* domain, MonoClass* klass, size_t size0, size_t size1, size_t size2)
{
    return g_HostStruct->unity_array_new_3d(domain, klass, size0, size1, size2);
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_array_object_header_size ()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_assembly_mempool_chunk_foreach (MonoAssembly * assembly, MonoDataFunc callback, void* userData)
{
    ASSERT_NOT_IMPLEMENTED;
}

#if defined(HOST_OSX) || defined(HOST_UNIX)
extern "C" EXPORT_API int EXPORT_CC mono_unity_backtrace_from_context(void* context, void* array[], int count)
{
    // Not implemented yet. Returning no frames allows code to continue without
    // stack trace support.
    return 0;
}
#endif

extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_class_field_is_literal (MonoClassField * field)
{
    ASSERT_NOT_IMPLEMENTED;
    return FALSE;
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_class_get_data_size (MonoClass * klass)
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API MonoClass* EXPORT_CC mono_unity_class_get_generic_type_definition (MonoClass * klass)
{
    CONTRACTL{
        PRECONDITION(klass != nullptr);
    } CONTRACTL_END;
    // there must be a better way!
    return mono_class_from_name(mono_class_get_image(klass), mono_class_get_namespace(klass), mono_class_get_name(klass));
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_class_has_failure (MonoClass * klass)
{
#ifndef DACCESS_COMPILE
    MonoClass_clr* clrClass = reinterpret_cast<MonoClass_clr*>(klass);
    // If the class is inited, it can't have a failure (see MethodTable::DoRunClassInitThrowing() for details)
    if (clrClass->IsClassInited())
        return FALSE;

    // Otherwise it is either not loaded or failed init
    return clrClass->IsInitError();
#else
    // No way to check this without IsInitError missing
    return FALSE;
#endif
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_class_is_abstract(MonoClass* klass)
{
    return g_HostStruct->unity_class_is_abstract(klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_class_is_interface(MonoClass* klass)
{
    return g_HostStruct->unity_class_is_interface(klass);
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_domain_mempool_chunk_foreach (MonoDomain * domain, MonoDataFunc callback, void* userData)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_g_free(void* p)
{
    free(p);
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_gc_handles_foreach_get_target (MonoDataFunc callback, void* userData)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_image_set_mempool_chunk_foreach (MonoDataFunc callback, void* userdata)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void* EXPORT_CC mono_unity_liveness_allocate_struct(MonoClass* filter, int max_object_count, mono_register_object_callback callback, void* userdata, mono_liveness_reallocate_callback reallocate)
{
    ASSERT_NOT_IMPLEMENTED;
    return NULL;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_liveness_calculation_from_root(MonoObject* root, void* state)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_liveness_calculation_from_statics(void* state)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_liveness_finalize(void* state)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_liveness_free_struct(void* state)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API MonoException* EXPORT_CC mono_unity_loader_get_last_error_and_error_prepare_exception()
{
    //ASSERT_NOT_IMPLEMENTED;
    return NULL;
}

extern "C" EXPORT_API int EXPORT_CC mono_unity_managed_callstack(unsigned char* buffer, int bufferSize, const MonoUnityCallstackOptions * opts)
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API void* EXPORT_CC mono_unity_method_get_function_pointer(MonoMethod* method)
{
    return g_HostStruct->unity_method_get_function_pointer(method);
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_object_header_size()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_offset_of_array_bounds_in_array_object_header()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API uint32_t EXPORT_CC mono_unity_offset_of_array_length_in_array_object_header()
{
    ASSERT_NOT_IMPLEMENTED;
    return 0;
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_set_vprintf_func(vprintf_func func)
{
    our_vprintf = func;
}

extern "C" EXPORT_API MonoString* EXPORT_CC mono_unity_string_empty_wrapper()
{
    return mono_string_new_wrapper("");
}

extern "C" EXPORT_API void EXPORT_CC mono_unity_type_get_name_full_chunked(MonoType * type, MonoDataFunc appendCallback, void* userData)
{
    ASSERT_NOT_IMPLEMENTED;
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_type_is_pointer_type(MonoType * type)
{
    ASSERT_NOT_IMPLEMENTED;
    return FALSE;
}

extern "C" EXPORT_API gboolean EXPORT_CC mono_unity_type_is_static(MonoType * type)
{
    ASSERT_NOT_IMPLEMENTED;
    return FALSE;
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_value_box(MonoDomain* domain, MonoClass* klass, gpointer val)
{
    return g_HostStruct->value_box(domain, klass, val);
}

#ifdef _DEBUG
extern "C" void EXPORT_CC mono_debug_assert_dialog(const char *szFile, int iLine, const char *szExpr)
{
    DbgAssertDialog(szFile, iLine, szExpr);
}
#endif

extern "C" EXPORT_API int EXPORT_CC mono_array_length(MonoArray* array)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->array_length(array);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_unity_class_get_attribute(MonoClass* klass, MonoClass* attr_klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_class_get_attribute(klass, attr_klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_unity_assembly_get_attribute(MonoAssembly* assembly, MonoClass* attr_klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_assembly_get_attribute(assembly, attr_klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_unity_method_get_attribute(MonoMethod* method, MonoClass* attr_class)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_method_get_attribute(method, attr_class);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API MonoObject* EXPORT_CC mono_unity_field_get_attribute(MonoClass* klass, MonoClassField* field, MonoClass* attr_class)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_field_get_attribute(klass, field, attr_class);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC unity_mono_method_is_generic_specific(MonoMethod* method, MonoClass* klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_mono_method_is_generic_specific(method, klass);
}

// Generated by UnityEmbedHost.Generator - Commit these changes
extern "C" EXPORT_API gboolean EXPORT_CC unity_mono_method_is_inflated_specific(MonoMethod* method, MonoClass* klass)
{
    GCX_PREEMP(); // temporary until we sort out our GC thread model
    return g_HostStruct->unity_mono_method_is_inflated_specific(method, klass);
}

extern "C" EXPORT_API void EXPORT_CC coreclr_unity_profiler_register(const CLSID* classId, const guint16* profilerDllPathUtf16)
{
    STATIC_CONTRACT_NOTHROW;

    StoredProfilerNode *profilerData = new StoredProfilerNode();
    profilerData->guid = *classId;
    profilerData->path.Set(reinterpret_cast<LPCWSTR>(profilerDllPathUtf16));

    g_profControlBlock.storedProfilers.InsertHead(profilerData);
}
